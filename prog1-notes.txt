We can construct the search tree implicitly using a node class.

Node{
State current
Node parent
String action taken to enter this state
Int cost of entering this state}
--
How to do the search:

create start state
frontier = {start}
while(true):
	if frontier is empty, return "fail"
current = frontier.pop()
if current.isGoal() return "success"
for each legal action in current state:
	frontier.add(new Node with current state expanded);

This finds a goal node, and the path taken to that goal node is the solution.
--
example admissible heuristic: (# of Dirts - 1)*Min distance between dirts +
				Manhattan distance from Home to furthest dirt +
				Manhattan distance from agent to furthest dirt

Estimated size of state space: W*L*D*4

Estimated performance of:

DFS: Not great. It is incomplete without a check for duplicate visited states,
and not optimal. Its time complexity of O(b^m) is massively worse than BFS in 
the worst case, but its space complexity of O(bm) is significantly better than 
that of BFS.

BFS: Some good, some bad. It's complete, but not optimal. Its time complexity of
O(b^d) is better than DFS, and its space complexity of O(b^d) is significantly 
worse than DFS.

Uniform Search: 
Both complete and optimal. Its time and space complexity are O(b^(1+C/e)).
--
Frontier ordering:

DFS- New nodes are inserted at back of frontier
BFS- New nodes are inserted at front of frontier
Uniform- Nodes are sorted in increasing cost

old thing: public Collection<String> legalActions() {
		Collection<String> actions = new ArrayList<String>();
		//legal actions to perform in this state. can be used to cull nonsense actions.
		if(!isOn) {
			actions.add("TURN_ON");
			return actions;
		}
		if(isOn && currentPos.equals(home) && dirt.isEmpty()) {
			actions.add("TURN_OFF");
			return actions;
		}
		for(Coordinate d : dirt) {
			if(d.equals(currentPos)) actions.add("SUCK");
			return actions;
		}
		//If square in front of agent is empty, GO is legal move.
		Coordinate nextSquare = new Coordinate();
		switch(ori) {
		case NORTH:
			nextSquare.set(this.currentPos.getX(), this.currentPos.getY() + 1);
			break;
		case SOUTH:
			nextSquare.set(this.currentPos.getX(), this.currentPos.getY() - 1);
			break;
		case EAST:
			nextSquare.set(this.currentPos.getX() + 1, this.currentPos.getY());
			break;
		case WEST:
			nextSquare.set(this.currentPos.getX() - 1, this.currentPos.getY());
			break;
		}
		boolean isBlocked = false;
		for(Coordinate o : obstacles) {
			if(nextSquare.equals(o)) {
				isBlocked = true;
			}
		}
		if(!isBlocked) {
			actions.add("GO");
		}
		actions.add("TURN_LEFT");
		actions.add("TURN_RIGHT");
		return actions;
	}